<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>4 Interactive Mountains — WebGL2</title>
  <style>
    html,body{height:100%;margin:0;background:#111;color:#ddd;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    canvas{display:block;width:100vw;height:100vh}
    #ui{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.4);padding:10px;border-radius:8px}
    #ui p{margin:6px 0 0 0;font-size:13px}
    a{color:#7bd}
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<div id="ui">
  <strong>4 Mountains — Mouse interaction</strong>
  <p>Move your mouse horizontally to hover a mountain. Move mouse up/down while hovering to change its height.</p>
  <p>Tip: Resize the window or use touch (touch moves) — touch X picks mountain, vertical drag adjusts its height.</p>
</div>

<script id="vs" type="x-shader/x-vertex">#version 300 es
precision highp float;
layout(location=0) in vec2 a_pos;
out vec2 v_uv;
void main(){
  v_uv = a_pos * 0.5 + 0.5;
  gl_Position = vec4(a_pos,0.0,1.0);
}
</script>

<script id="fs" type="x-shader/x-fragment">#version 300 es
precision highp float;
out vec4 fragColor;
in vec2 v_uv;
uniform vec2 iResolution;
uniform float iTime;
uniform vec4 heights; // heights of the 4 mountains
uniform vec4 mpos;    // mountain x positions (world space)

// camera
vec3 camPos = vec3(0.0, 3.0, 10.0);
vec3 camTarget = vec3(0.0, 0.7, 0.0);

// evaluate heightfield (sum of Gaussians)
float mountainHeight(vec2 p){
    float h = 0.0;
    // width parameter (controls spread)
    float spread = 1.5;
    for(int i=0;i<4;i++){
        float mx = mpos[i];
        float dx = p.x - mx;
        float dz = p.y; // we map z to p.y when calling
        float r2 = dx*dx + dz*dz;
        // Gaussian-like bump
        float bh = heights[i] * exp(-r2/(2.0*spread*spread));
        h += bh;
    }
    // add small ground undulation
    h += 0.08 * sin(p.x*0.6 + iTime*0.2) * cos(p.y*0.4 + iTime*0.15);
    return h;
}

// distance estimator for heightfield: signed distance from point to surface y = mountainHeight(x,z)
float map(vec3 p){
    float h = mountainHeight(vec2(p.x, p.z));
    return p.y - h;
}

vec3 getNormal(vec3 p){
    float eps = 0.001;
    float dx = map(p + vec3(eps,0.0,0.0)) - map(p - vec3(eps,0.0,0.0));
    float dy = map(p + vec3(0.0,eps,0.0)) - map(p - vec3(0.0,eps,0.0));
    float dz = map(p + vec3(0.0,0.0,eps)) - map(p - vec3(0.0,0.0,eps));
    return normalize(vec3(dx,dy,dz));
}

// simple phong lighting
vec3 lighting(vec3 p, vec3 rd, vec3 n){
    vec3 lightPos = vec3(5.0, 8.0, 6.0);
    vec3 L = normalize(lightPos - p);
    vec3 V = normalize(-rd);
    vec3 R = reflect(-L, n);
    float diff = max(dot(n, L), 0.0);
    float spec = pow(max(dot(R, V), 0.0), 32.0);
    float ambient = 0.20;
    vec3 base = mix(vec3(0.2,0.35,0.1), vec3(0.5,0.4,0.25), clamp(p.y/3.0,0.0,1.0));
    vec3 color = base * (ambient + 0.9*diff) + vec3(1.0)*0.5*spec;
    return color;
}

// raymarching along ray ro + t*rd
float rayMarch(vec3 ro, vec3 rd, out vec3 hitPos, out int steps){
    float t = 0.0;
    const int MAX_STEPS = 120;
    const float MAX_DIST = 60.0;
    const float SURF_EPS = 0.0015;
    for(int i=0;i<MAX_STEPS;i++){
        vec3 p = ro + rd * t;
        float d = map(p);
        if(d < SURF_EPS) { hitPos = p; steps = i; return t; }
        if(t > MAX_DIST) break;
        t += d * 0.8; // step scale
    }
    steps = MAX_STEPS;
    hitPos = ro + rd * t;
    return -1.0;
}

void main(){
    // build camera basis
    vec2 uv = (v_uv * 2.0 - 1.0);
    float aspect = iResolution.x / iResolution.y;
    uv.x *= aspect;

    vec3 forward = normalize(camTarget - camPos);
    vec3 right = normalize(cross(vec3(0.0,1.0,0.0), forward));
    vec3 up = normalize(cross(forward, right));

    float fov = 45.0;
    float f = tan(radians(fov)*0.5);
    vec3 rd = normalize(forward + uv.x * right * f + uv.y * up * f);
    vec3 ro = camPos;

    vec3 hitPos;
    int steps;
    float t = rayMarch(ro, rd, hitPos, steps);
    vec3 col = vec3(0.55,0.75,0.95) * (1.0 - smoothstep(0.0, 1.0, rd.y*2.0)); // sky gradient

    if(t > 0.0){
        vec3 n = getNormal(hitPos);
        vec3 lit = lighting(hitPos, rd, n);
        // fog
        float fog = exp(-0.02 * t * t);
        col = mix(vec3(0.6,0.75,0.9), lit, fog);
    }

    // add simple rim / silhouette
    fragColor = vec4(pow(clamp(col,0.0,1.0), vec3(1.0/2.2)), 1.0);
}
</script>

<script>
(() => {
  const canvas = document.getElementById('glcanvas');
  const gl = canvas.getContext('webgl2', { antialias: true });
  if(!gl){
    document.body.innerHTML = '<div style="color:#faa;padding:20px">WebGL2 not available in your browser.</div>';
    return;
  }

  function fitCanvas(){
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    gl.viewport(0,0,canvas.width, canvas.height);
  }
  fitCanvas();
  window.addEventListener('resize', fitCanvas);

  function compileShader(id, type){
    const el = document.getElementById(id);
    const src = el.textContent;
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(s));
      throw new Error('Shader compile error:\n'+gl.getShaderInfoLog(s));
    }
    return s;
  }

  const vs = compileShader('vs', gl.VERTEX_SHADER);
  const fs = compileShader('fs', gl.FRAGMENT_SHADER);
  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.bindAttribLocation(prog, 0, 'a_pos');
  gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(prog));
  }

  const quad = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quad);
  // full-screen triangle pair (2 triangles)
  const data = new Float32Array([
    -1,-1,  1,-1,  -1,1,
    -1,1,   1,-1,   1,1
  ]);
  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

  gl.useProgram(prog);
  gl.enableVertexAttribArray(0);
  gl.bindBuffer(gl.ARRAY_BUFFER, quad);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

  const uResolution = gl.getUniformLocation(prog, 'iResolution');
  const uTime = gl.getUniformLocation(prog, 'iTime');
  const uHeights = gl.getUniformLocation(prog, 'heights');
  const uMpos = gl.getUniformLocation(prog, 'mpos');

  // mountain world x positions
  const mountainPositions = [-4.5, -1.5, 1.5, 4.5];
  let heights = [0.9, 1.6, 1.0, 0.8];

  // mouse handling
  let mouse = {x:0.5, y:0.5, down:false};
  function getMousePos(e){
    const rect = canvas.getBoundingClientRect();
    let clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0].clientX);
    let clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0].clientY);
    return {
      x: (clientX - rect.left) / rect.width,
      y: (clientY - rect.top) / rect.height
    };
  }

  function onPointerMove(e){
    const pos = getMousePos(e);
    mouse.x = pos.x;
    mouse.y = pos.y;
    // map mouse x to world x
    const worldX = (mouse.x - 0.5) * (canvas.width / canvas.height) * 6.0; // match aspect and world scale
    // pick nearest mountain
    let nearest = -1; let minD = 1e9;
    for(let i=0;i<4;i++){
      const d = Math.abs(worldX - mountainPositions[i]);
      if(d < minD){ minD = d; nearest = i; }
    }
    const pickThreshold = 1.6; // world units
    if(minD < pickThreshold){
      // if hovering over mountain, update its height based on mouse.y (invert so up increases height)
      const newH = 0.2 + (1.8 * (1.0 - mouse.y));
      heights[nearest] = newH;
    }
  }

  canvas.addEventListener('mousemove', onPointerMove);
  canvas.addEventListener('touchmove', (e)=>{ e.preventDefault(); onPointerMove(e); }, {passive:false});

  // pass uniforms and render
  let start = performance.now();
  function render(){
    const now = performance.now();
    const t = (now - start) * 0.001;
    gl.useProgram(prog);
    gl.uniform2f(uResolution, canvas.width, canvas.height);
    gl.uniform1f(uTime, t);
    gl.uniform4f(uHeights, heights[0], heights[1], heights[2], heights[3]);
    gl.uniform4f(uMpos, mountainPositions[0], mountainPositions[1], mountainPositions[2], mountainPositions[3]);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

})();
</script>
</body>
</html>
